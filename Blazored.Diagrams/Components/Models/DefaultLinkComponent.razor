@using Blazored.Diagrams.Services.Diagrams
@using Blazored.Diagrams.Services.Events
@implements IDisposable
@if (Link is not null)
{
    <svg style="width: 100%; height: 100%;overflow:visible;">
        <defs>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"/>
                <feFlood flood-color="#C0C0C0" result="flood"/>
                <feComposite in="flood" in2="blur" operator="in" result="colorBlur"/>
                <feMerge>
                    <feMergeNode in="colorBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
        <path d="@GetPath()"
              style="pointer-events: auto"
              id="@(PathId)"
              fill="none"
              stroke="@_strokeColor"
              stroke-width="@(StrokeWidth)"
              @onpointerleave="HandlePointerLeave"
              @onpointerdown="HandlePointerDown"
              @onpointerenter="HandlePointerEnter"
              @onpointermove="HandlePointerMove"
              @onpointerup="HandlePointerUp"
              @onwheel="ctx => DiagramService.Events.Publish(new LinkWheelEvent(Link, ctx))"
              @onclick="HandleClick"
              @ondblclick="HandleDoubleClick"/>

    </svg>
}

@code {

    private string _strokeColor = null!;

    /// <summary>
    ///     Link to be rendered.
    /// </summary>
    [Parameter]
    public required Link Link { get; set; }

    /// <summary>
    /// Service cascaded through the <see cref="LinkContainer"/>
    /// </summary>
    [CascadingParameter]
    public IDiagramService DiagramService { get; set; } = null!;

    [Inject] private IJSRuntime Js { get; set; } = null!;

    /// <summary>
    ///     The <see cref="LinkContainer"/> that renders the component.
    /// </summary>
    [CascadingParameter]
    public required LinkContainer Container { get; set; }
    
    /// <summary>
    ///     Color of the link path. Default is black.
    /// </summary>
    [Parameter] public string StrokeColor { get; set; } = "black";

    /// <summary>
    /// Color of the link path when it's selected. Default is gray.
    /// </summary>
    [Parameter] public string SelectedStrokeColor { get; set; } = "gray";

    /// <summary>
    ///     Width of the path. Default is 4.
    /// </summary>
    [Parameter] public int StrokeWidth { get; set; } = 4;
    
    /// <summary>
    ///     Function that generates a path when <see cref="DefaultLinkComponentPathType"/> is <see cref="Models.DefaultLinkComponentPathType.Custom"/>.
    /// </summary>
    [Parameter] public Func<string> CustomLinkPath  { get; set; } = null!;

    /// <summary>
    ///     ID of the element.
    /// </summary>
    public string PathId => $"link-path-{Link.Id}";

    private List<IDisposable> _subcriptions = [];

    /// <inheritdoc />
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _subcriptions = [DiagramService.Events.SubscribeWhere<LinkSelectionChangedEvent>(p=> p.Model.Id == Link.Id,OnLinkSelectionChanged)];
            _strokeColor = Link.IsSelected ? SelectedStrokeColor : StrokeColor; 
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    private void OnLinkSelectionChanged(LinkSelectionChangedEvent obj)
    {
        _strokeColor = obj.Model.IsSelected ? SelectedStrokeColor : StrokeColor; 
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkClickedEvent(Link, e));
        }
    }

    private async Task HandleDoubleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkDoubleClickedEvent(Link, e));
        }
    }

    private async Task HandlePointerDown(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerDownEvent(Link, e));
        }
    }

    private async Task HandlePointerUp(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerUpEvent(Link, e));
        }
    }

    private async Task HandlePointerLeave(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerLeaveEvent(Link, e));
        }
    }

    private async Task HandlePointerEnter(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerEnterEvent(Link, e));
        }
    }

    private async Task HandlePointerMove(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerMoveEvent(Link, e));
        }
    }

    protected int RelativeX1 => Link.SourcePort.GetCenterCoordinates().CenterX - Container.PositionX;
    protected int RelativeY1 => Link.SourcePort.GetCenterCoordinates().CenterY - Container.PositionY;
    protected int RelativeX2 => Container.TargetX - Container.PositionX;
    protected int RelativeY2 => Container.TargetY - Container.PositionY;
    
    
    /// <summary>
    /// Gets the path to be drawn on the svg.
    /// </summary>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    protected virtual string GetPath()
    {
       return string.Empty;
    }

    /// <inheritdoc />
    public void Dispose()
    {
       _subcriptions.DisposeAll();
    }

}