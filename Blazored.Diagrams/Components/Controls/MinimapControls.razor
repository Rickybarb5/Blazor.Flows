@using System.Globalization
@using Blazored.Diagrams.Services.Diagrams
@implements IDisposable
<div class="minimap-container @Class" style="@Style">

    @if (Service is not null)
    {
        <svg class="minimap-svg"
             width="@Width"
             height="@Height"
             viewBox="@($"{_viewBoxMinX.ToString(_nfi)} {_viewBoxMinY.ToString(_nfi)} {_viewBoxWidth.ToString(_nfi)} {_viewBoxHeight.ToString(_nfi)}")">

            @foreach (var group in Service.Diagram.AllGroups)
            {
                <rect
                    class="minimap-group"
                    x="@group.PositionX"
                    y="@group.PositionY"
                    width="@group.Width"
                    height="@group.Height"
                    fill="@GroupColor">
                </rect>
            }

            @foreach (var node in Service.Diagram.AllNodes)
            {
                <rect
                    class="minimap-node"
                    x="@node.PositionX"
                    y="@node.PositionY"
                    width="@node.Width"
                    height="@node.Height"
                    fill="@NodeColor">
                </rect>
            }

            @foreach (var link in Service.Diagram.AllLinks)
            {
                if (link.SourcePort is not null)
                {
                    var sourceCenter = Service.GetCenterCoordinates(link.SourcePort);
                    var x1 = sourceCenter.CenterX;
                    var y1 = sourceCenter.CenterY;
                    var x2 = link.TargetPositionX;
                    var y2 = link.TargetPositionY;

                    <line
                        class="minimap-link"
                        x1="@x1.ToString(_nfi)"
                        y1="@y1.ToString(_nfi)"
                        x2="@x2.ToString(_nfi)"
                        y2="@y2.ToString(_nfi)"
                        stroke="@LinkColor"
                        stroke-width="4">
                    </line>
                }
            }

            @foreach (var port in Service.Diagram.AllPorts)
            {
                <circle
                    class="minimap-port"
                    cx="@(port.PositionX.ToString(_nfi))"
                    cy="@(port.PositionY.ToString(_nfi))"
                    r="@((port.Width/2).ToString(_nfi))"
                    fill="@PortColor">
                </circle>
            }

            @* --- Render Current Viewport --- *@
            <rect class="minimap-current-view"
                  x="@_viewportRectX.ToString(_nfi)"
                  y="@_viewportRectY.ToString(_nfi)"
                  width="@_viewportRectWidth.ToString(_nfi)"
                  height="@_viewportRectHeight.ToString(_nfi)"
                  fill="none"
                  stroke="@ViewStrokeColor"
                  stroke-width="@ViewStrokeWidth">
            </rect>

        </svg>

        <div class="minimap-info-overlay">
            <div class="minimap-info-item">
                <span class="minimap-info-label">Zoom:</span> 
                <span>@Service.Diagram.Zoom.ToString("F2")X</span>
            </div>
            <div class="minimap-info-item">
                <span class="minimap-info-label">Pan:</span> 
                <span>(@Service.Diagram.PanX.ToString("F0"), @Service.Diagram.PanY.ToString("F0"))</span>
            </div>
        </div>
    }
</div>

@code
{
    readonly NumberFormatInfo _nfi = new();
    private double _viewBoxMinX;
    private double _viewBoxMinY;
    private double _viewBoxWidth;
    private double _viewBoxHeight;
    private double _calculatedMargin;
    private double _viewportRectX;
    private double _viewportRectY;
    private double _viewportRectWidth;
    private double _viewportRectHeight;

    private List<IDisposable> _subscriptions = new List<IDisposable>();

    [CascadingParameter] 
    private IDiagramService Service { get; set; } = null!;

    [Parameter] public double Width { get; set; } 
    [Parameter] public double Height { get; set; }
    [Parameter] public double Margin { get; set; } = 5;
    [Parameter] public string NodeColor { get; set; } = "#40babd";
    [Parameter] public string GroupColor { get; set; } = "#9fd0d1";
    [Parameter] public string PortColor { get; set; } = "#000000"; 
    [Parameter] public int PortRadius { get; set; } = 2; 
    [Parameter] public string LinkColor { get; set; } = "black"; 
    [Parameter] public string ViewStrokeColor { get; set; } = "#40babd";
    [Parameter] public int ViewStrokeWidth { get; set; } = 4;
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? Style { get; set; }

    /// <inheritdoc />
    public void Dispose()
    {
        foreach (var subscription in _subscriptions)
        {
            subscription.Dispose();
        }

        _subscriptions.Clear();
    }

    /// <inheritdoc />
    protected override Task OnInitializedAsync()
    {
        _nfi.NumberDecimalSeparator = ".";
        _nfi.NumberDecimalDigits = 3;
        return base.OnInitializedAsync();
    }
    
    /// <inheritdoc />
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _subscriptions =
            [
                Service.Events.SubscribeTo<NodeAddedEvent>(Refresh),
                Service.Events.SubscribeTo<NodePositionChangedEvent>(Refresh),
                Service.Events.SubscribeTo<NodeRemovedEvent>(Refresh),
                Service.Events.SubscribeTo<GroupAddedEvent>(Refresh),
                Service.Events.SubscribeTo<GroupRemovedEvent>(Refresh),
                Service.Events.SubscribeTo<GroupPositionChangedEvent>(Refresh),
                Service.Events.SubscribeTo<PortAddedEvent>(Refresh),
                Service.Events.SubscribeTo<PortRemovedEvent>(Refresh),
                Service.Events.SubscribeTo<PortPositionChangedEvent>(Refresh),
                Service.Events.SubscribeTo<LinkAddedEvent>(Refresh),
                Service.Events.SubscribeTo<LinkRemovedEvent>(Refresh),
                Service.Events.SubscribeTo<DiagramPanChangedEvent>(Refresh),
                Service.Events.SubscribeTo<DiagramZoomChangedEvent>(Refresh),
                Service.Events.SubscribeTo<DiagramSizeChangedEvent>(UpdateSize),
            ];
           
            Refresh(null!);
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private void UpdateSize(DiagramSizeChangedEvent obj)
    {
        Width = Service.Diagram.Width / 8;
        Height = Service.Diagram.Height / 8;
        Refresh(null!);
        StateHasChanged();
    }

    private void Refresh(IEvent? e)
    {
        CalculateViewport();

        var minX = _viewportRectX;
        var minY = _viewportRectY;
        var maxX = _viewportRectX + _viewportRectWidth;
        var maxY = _viewportRectY + _viewportRectHeight;

        var bounds = Service.GetAllBounds();
        foreach (var bound in bounds)
        {
            minX = Math.Min(minX, bound.Left);
            minY = Math.Min(minY, bound.Top);
            maxX = Math.Max(maxX, bound.Right);
            maxY = Math.Max(maxY, bound.Bottom);
        }
        
        CalculateViewBox(maxX,maxY, minX, minY);
        InvokeAsync(StateHasChanged);
    }

    private void CalculateViewport()
    {
        _viewportRectX = -Service.Diagram.PanX / (double)Service.Diagram.Zoom;
        _viewportRectY = -Service.Diagram.PanY / (double)Service.Diagram.Zoom;
        _viewportRectWidth = Service.Diagram.Width / (double)Service.Diagram.Zoom;
        _viewportRectHeight = Service.Diagram.Height / (double)Service.Diagram.Zoom;
    }

    private void CalculateViewBox(double maxX, double maxY, double minX, double minY)
    {
        var width = maxX - minX;
        var height = maxY - minY;
        var scaledWidth = width / Width;
        var scaledHeight = height / Height;
        var scale = Math.Max(scaledWidth, scaledHeight);
        var viewWidth = scale * Width;
        var viewHeight = scale * Height;
        
        _calculatedMargin = Margin * scale;
        _viewBoxMinX = minX - (viewWidth - width) / 2 - _calculatedMargin;
        _viewBoxMinY = minY - (viewHeight - height) / 2 - _calculatedMargin;
        _viewBoxWidth = viewWidth + _calculatedMargin * 2;
        _viewBoxHeight = viewHeight + _calculatedMargin * 2;
    }
}